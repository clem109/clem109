(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{203:function(e,t){e.exports={body:"At Thriva we are hard at work building the world’s first preventative healthcare company to change the way in which people think about their health. We deeply care about ensuring all our customers have a seamless experience when using our service and one of the ways we do this is by writing end-to-end (E2E) tests using Cypress. Cypress allows you to automate the way in which users interact with the application in the browser, this can be extremely useful for catching bugs but also during the development process.\n\n![](https://cdn-images-1.medium.com/max/2000/1*k4-5E9kKm4oqb6wn4FmaSg.jpeg)\n\n## What is Cypress?\n\nCypress is a javascript framework for writing E2E tests for web applications, it has mocking, stubbing and assertions built in. As it was built from the ground up, it doesn’t use Selenium at all and is (usually) very performant.\n\nWriting the E2E tests is usually trivial, however we came across a few issues which I will detail in this article that should be useful for anyone else using Cypress.\n\n## Setup\n\nThe majority of the Thriva website is built using [Vue.js](https://vuejs.org/), as we scaffolded the project with the Vue cli we get Cypress installed out of the box. It is relatively easy to install by [following the instructions in the docs](https://docs.cypress.io/guides/getting-started/installing-cypress.html)\n\nBelow is the folder structure for Cypress:\n\n    # Cypress file structure\n    /fixtures\n    /plugins\n    /specs\n    /support\n\n* Fixtures — where you store the files that will be used to mock API calls, images, videos etc.\n\n* Plugins — provide a way of modifying the internal behaviour of Cypress\n\n* Specs — this is where you write your E2E tests\n\n* Support — a place to write utility functions, for example, a function that handles user authentication\n\n## Writing E2E tests\n\nThe Cypress docs are fairly comprehensive when it comes to describing the best way of writing E2E tests. Here I will show some of the more useful features that I found when writing E2E tests.\n\n## Stubbing data\n\nCypress allows you to catch API requests and stub out their data, below we are listening to GET requests to the /v1/auth API endpoint and we return the user fixture. Cypress is clever and is able to find the user.json file within the fixtures folder, we can also add stubs for images, videos etc.\n\n```javascript\ncy.server()\ncy.fixture('user').as('user')\ncy.route('GET', '/v1/auth', '@user')\n\n// user.json\n{\n  firstName: 'Clem',\n  lastName: 'JavaScript',\n  company: 'Thriva Health',\n  bloodResults: [\n    {\n      type: 'HbA1c',\n      result: 30.4,\n      units: 'mmol/mol',\n      severity: 'normal'\n    }\n  ]\n}\n```\n\n## Editing mocks on the fly\n\nSometimes you want to test the application under different states, for example, let’s say that we want to test the graph which displays our blood results for a different result value and a high severity. We can edit the fixture before it is used in the test:\n\n```javascript\ncy.server()\ncy.fixture('user').then((user) => {\n  user.bloodResults = [\n    {\n      type: 'HbA1c',\n      result: 60.3,\n      units: 'mmol/mol',\n      severity: 'high'\n    }\n  ]\n  cy.route('GET', 'v1/auth/**', user).as('user')\n})\n```\n\n## Waiting for API requests\n\nIn certain situations you want to call a real API, perhaps to test your authentication flow. In this case you would want to wait for the API to resolve before continuing with the test. At Thriva we have a page where you can personalise your blood tests to your own personal needs, we need to call our API to get all the pricing’s for all of the different types of tests we offer. We can use cy.wait() to wait for the API to finish before performing our E2E tests:\n\n```javascript\ncy.server()\ncy.route({\n  method: 'GET',\n  url: `/v1/blood_tests`\n}).as('bloodTests')\ncy.wait('@blootTests')\n\n// once this has resolved then the rest of the tests can be run\n```\n\n## Writing tests for different devices\n\nBy default Cypress runs in a desktop web browser, in reality there is a high probability that the vast majority of your users are accessing the website with their mobile device. Cypress allows you to run your tests as though you were interacting with the app on a mobile, tablet and/or desktop:\n\n```javascript\n// Good\nbeforeAll(() => {\n  cy.viewport('iphone-6')\n})\n\n// Bad - each time you write an it assertion the browser will reset to a desktop browser.\nbefore(() => {\n  cy.viewport('iphone-6')\n})\n```\n\nThe viewport function can take different parameters to render the page at different screen resolutions.\n\n## E2E tests are not unit tests\n\nWhen writing E2E tests it is not necessary to write assertions for everything like you would in a unit test. Rather, it is better to write assertions for overall functionality — Cypress was designed to be written this way:\n\n```javascript\ndescribe('To do app', () => {\n  context('Desktop', () => {\n    before(() => {\n      //mock out auth\n      cy.server()\n      cy.fixture('user').as('user')\n      cy.route('GET', '/v1/auth', '@user')\n      // mock out todos\n      cy.fixture('todos').as('todos')\n      cy.route('GET', '/v1/todos', '@todos')\n    })\n    \n    // GOOD\n    it('should be able to add and remove items to the todos', () =>      {\n    // logic to add and remove tests, asserting class names present \n    // and correct to do length\n      Cypress._.times(3, (i) => {\n        cy.get('.todo-input').type(`test: ${i}`)\n        cy.contains('Add todo').click()\n      })\n      cy.get('.todo').should('have.length', 3)\n\n      Cypress._.times(3, (i) => {\n        cy.get('.remove-todo').first().click()\n      })\n      cy.get('.todo').should('have.length', 0)\n}\n\n    // BAD\n    it('should have the .added class when todo is added')\n\n    // BAD\n    it('should have X number of items added to the todo list')\n  })\n})\n```\n\n## Selector Playground\n\nThe selector playground is probably my favourite feature about Cypress, rather than having to write out all your CSS selectors to find the DOM elements manually this tools finds them for you. [The documentation](https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground) explains very well how to use this correctly.\n\n## Look within\n\nThere are times when it is difficult to write query selectors as there are multiple places where there could be a match, this is particularly problematic on forms if you are trying to find a particular input element. Cypress allows you to find the parent DOM element and only look at the child elements within it:\n```html\n<form class='some-form'>\n  <div id='one'>\n    <input />\n  </div>\n  \n  <div id='two'>\n    <input />\n  </div>\n  \n  <div id='three'>\n    <input />\n  </div>\n</form>\n```\n\nLets say you want to go through the form and fill out each individual input:\n\n```javascript\ncy.within('#one', ($el) => { \n  cy.get('input').type('Hello')\n})\n\ncy.within('#two', ($el) => { \n  cy.get('input').type('Maybe')\n})\n\ncy.within('#three', ($el) => { \n  cy.get('input').type('Bye')\n})\n```\n\n## Keep it DRY\n\nThere are certain checks that you may want to do multiple times, or actions you want to perform before each test. Cypress gives you the ability to write your own custom commands to be used throughout the testing suite. One that we use extensively is cy.auth(), this is a command that mocks out the authentication request as all of our routes are protected. You can also add other commands for any tasks you do repeatedly.\n\n```javascript\nCypress.Commands.add('auth', () => {\n  cy.server()\n  cy.fixture('auth').as('auth')\n  cy.route('GET', '/v1/auth', '@auth')\n})\n\n// This can be called within our tests like this:\ncy.auth()\n```\n\n## Common issues faced\n\nWhen building out or E2E tests there were a number of issues that we had to overcome to ensure that they work reliably. Our major pain point was in our CI environment (Circle CI) the tests would fail very often.\n\n![](https://cdn-images-1.medium.com/max/2000/1*rzBqx4sW2xu4l8uWNJneBw.jpeg)\n\nThere can be a number of things that could be going wrong that can ultimately cause tests to fail but the first step is identifying where there are issues.\n\n## Page performance issues\n\nWe found that some of the pages were just not performant enough which would cause Cypress to timeout as it wasn’t able to find the DOM nodes in time as the javascript hadn’t finished evaluating. One of the ways to check this is to run the tests multiple times and find the ones that fail, you can do this by running the following command:\n\n```javascript\n// Run the tests x number of times\nCypress._.times(20, (i) => {\n  it(`something ${i} times`, () => {\n  \n  })\n})\n```\n\nTo take this a step further, as the tests are running in a chrome browser it is possible to throttle CPU and network speed. You can do this by clicking in Dev Tools>Performance\n\nIf you find tests are failing then it means that something on the page isn’t rendering fast enough for Cypress to find it. You can get past this by adding an increased timeout in your before hook but ideally you would fix the underlying problem:\n\n```javascript\n// Not ideal to do this as there is an underlying issue with \n// the page performance to necessitate doing this.\nbefore(() => {\n  Cypress.config('defaultCommandTimeout', 20000)\n})\n```\n\n## Fixtures were too large\n\nInitially, when we were writing our tests we were testing using real data from our staging environment, the issue with this is that if there are any issues with the API then the test will fail. A good rule of thumb is to test the critical routes ( e.g. authentication, purchases and anything critical for the business) with a real API and to stub out the rest of the API request/responses.\n\nAs we refactored our tests to use fixture data, one of the issues we faced when writing the tests was that the stubbing of the requests was failing if the JSON representation of the data was too large. Unfortunately, Cypress doesn’t warn you of this so it was only when digging through the Github issues we were able to discover this particular issue. We then had to manually go through the data and trim it down so that Cypress could be able to stub out the API calls correctly.\n\n## Best practices and key learnings\n\n- Mock out as much of the data as possible, ideally using factories to generate random data on the fly — we use [chance.js](https://chancejs.com/) for this purpose.\n\n- Mock everything except the critical routes.\n\n- If tests are failing it is more than likely an issue with your App rather than Cypress.\n\n- Performance test the pages where the tests are failing.\n\n- Use the [selector playground](https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground) for finding DOM elements, makes writing tests much quicker.\n\n- Don’t use the data property for finding elements, this can break once the JS/CSS is recompiled and these values change.\n\n- Use cy.wait() to wait for API calls to finish.\n\n- When writing frontend code where the state of the application needs to change via UI interaction, Cypress is a great way of automating it.\n",html:"<p>At Thriva we are hard at work building the world’s first preventative healthcare company to change the way in which people think about their health. We deeply care about ensuring all our customers have a seamless experience when using our service and one of the ways we do this is by writing end-to-end (E2E) tests using Cypress. Cypress allows you to automate the way in which users interact with the application in the browser, this can be extremely useful for catching bugs but also during the development process.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*k4-5E9kKm4oqb6wn4FmaSg.jpeg\" alt=\"\"></p>\n<h2>What is Cypress?</h2>\n<p>Cypress is a javascript framework for writing E2E tests for web applications, it has mocking, stubbing and assertions built in. As it was built from the ground up, it doesn’t use Selenium at all and is (usually) very performant.</p>\n<p>Writing the E2E tests is usually trivial, however we came across a few issues which I will detail in this article that should be useful for anyone else using Cypress.</p>\n<h2>Setup</h2>\n<p>The majority of the Thriva website is built using <a href=\"https://vuejs.org/\">Vue.js</a>, as we scaffolded the project with the Vue cli we get Cypress installed out of the box. It is relatively easy to install by <a href=\"https://docs.cypress.io/guides/getting-started/installing-cypress.html\">following the instructions in the docs</a></p>\n<p>Below is the folder structure for Cypress:</p>\n<pre><code># Cypress file structure\n/fixtures\n/plugins\n/specs\n/support\n</code></pre>\n<ul>\n<li>\n<p>Fixtures — where you store the files that will be used to mock API calls, images, videos etc.</p>\n</li>\n<li>\n<p>Plugins — provide a way of modifying the internal behaviour of Cypress</p>\n</li>\n<li>\n<p>Specs — this is where you write your E2E tests</p>\n</li>\n<li>\n<p>Support — a place to write utility functions, for example, a function that handles user authentication</p>\n</li>\n</ul>\n<h2>Writing E2E tests</h2>\n<p>The Cypress docs are fairly comprehensive when it comes to describing the best way of writing E2E tests. Here I will show some of the more useful features that I found when writing E2E tests.</p>\n<h2>Stubbing data</h2>\n<p>Cypress allows you to catch API requests and stub out their data, below we are listening to GET requests to the /v1/auth API endpoint and we return the user fixture. Cypress is clever and is able to find the user.json file within the fixtures folder, we can also add stubs for images, videos etc.</p>\n<pre><code class=\"language-javascript\">cy.server()\ncy.fixture('user').as('user')\ncy.route('GET', '/v1/auth', '@user')\n\n// user.json\n{\n  firstName: 'Clem',\n  lastName: 'JavaScript',\n  company: 'Thriva Health',\n  bloodResults: [\n    {\n      type: 'HbA1c',\n      result: 30.4,\n      units: 'mmol/mol',\n      severity: 'normal'\n    }\n  ]\n}\n</code></pre>\n<h2>Editing mocks on the fly</h2>\n<p>Sometimes you want to test the application under different states, for example, let’s say that we want to test the graph which displays our blood results for a different result value and a high severity. We can edit the fixture before it is used in the test:</p>\n<pre><code class=\"language-javascript\">cy.server()\ncy.fixture('user').then((user) =&gt; {\n  user.bloodResults = [\n    {\n      type: 'HbA1c',\n      result: 60.3,\n      units: 'mmol/mol',\n      severity: 'high'\n    }\n  ]\n  cy.route('GET', 'v1/auth/**', user).as('user')\n})\n</code></pre>\n<h2>Waiting for API requests</h2>\n<p>In certain situations you want to call a real API, perhaps to test your authentication flow. In this case you would want to wait for the API to resolve before continuing with the test. At Thriva we have a page where you can personalise your blood tests to your own personal needs, we need to call our API to get all the pricing’s for all of the different types of tests we offer. We can use cy.wait() to wait for the API to finish before performing our E2E tests:</p>\n<pre><code class=\"language-javascript\">cy.server()\ncy.route({\n  method: 'GET',\n  url: `/v1/blood_tests`\n}).as('bloodTests')\ncy.wait('@blootTests')\n\n// once this has resolved then the rest of the tests can be run\n</code></pre>\n<h2>Writing tests for different devices</h2>\n<p>By default Cypress runs in a desktop web browser, in reality there is a high probability that the vast majority of your users are accessing the website with their mobile device. Cypress allows you to run your tests as though you were interacting with the app on a mobile, tablet and/or desktop:</p>\n<pre><code class=\"language-javascript\">// Good\nbeforeAll(() =&gt; {\n  cy.viewport('iphone-6')\n})\n\n// Bad - each time you write an it assertion the browser will reset to a desktop browser.\nbefore(() =&gt; {\n  cy.viewport('iphone-6')\n})\n</code></pre>\n<p>The viewport function can take different parameters to render the page at different screen resolutions.</p>\n<h2>E2E tests are not unit tests</h2>\n<p>When writing E2E tests it is not necessary to write assertions for everything like you would in a unit test. Rather, it is better to write assertions for overall functionality — Cypress was designed to be written this way:</p>\n<pre><code class=\"language-javascript\">describe('To do app', () =&gt; {\n  context('Desktop', () =&gt; {\n    before(() =&gt; {\n      //mock out auth\n      cy.server()\n      cy.fixture('user').as('user')\n      cy.route('GET', '/v1/auth', '@user')\n      // mock out todos\n      cy.fixture('todos').as('todos')\n      cy.route('GET', '/v1/todos', '@todos')\n    })\n    \n    // GOOD\n    it('should be able to add and remove items to the todos', () =&gt;      {\n    // logic to add and remove tests, asserting class names present \n    // and correct to do length\n      Cypress._.times(3, (i) =&gt; {\n        cy.get('.todo-input').type(`test: ${i}`)\n        cy.contains('Add todo').click()\n      })\n      cy.get('.todo').should('have.length', 3)\n\n      Cypress._.times(3, (i) =&gt; {\n        cy.get('.remove-todo').first().click()\n      })\n      cy.get('.todo').should('have.length', 0)\n}\n\n    // BAD\n    it('should have the .added class when todo is added')\n\n    // BAD\n    it('should have X number of items added to the todo list')\n  })\n})\n</code></pre>\n<h2>Selector Playground</h2>\n<p>The selector playground is probably my favourite feature about Cypress, rather than having to write out all your CSS selectors to find the DOM elements manually this tools finds them for you. <a href=\"https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground\">The documentation</a> explains very well how to use this correctly.</p>\n<h2>Look within</h2>\n<p>There are times when it is difficult to write query selectors as there are multiple places where there could be a match, this is particularly problematic on forms if you are trying to find a particular input element. Cypress allows you to find the parent DOM element and only look at the child elements within it:</p>\n<pre><code class=\"language-html\">&lt;form class='some-form'&gt;\n  &lt;div id='one'&gt;\n    &lt;input /&gt;\n  &lt;/div&gt;\n  \n  &lt;div id='two'&gt;\n    &lt;input /&gt;\n  &lt;/div&gt;\n  \n  &lt;div id='three'&gt;\n    &lt;input /&gt;\n  &lt;/div&gt;\n&lt;/form&gt;\n</code></pre>\n<p>Lets say you want to go through the form and fill out each individual input:</p>\n<pre><code class=\"language-javascript\">cy.within('#one', ($el) =&gt; { \n  cy.get('input').type('Hello')\n})\n\ncy.within('#two', ($el) =&gt; { \n  cy.get('input').type('Maybe')\n})\n\ncy.within('#three', ($el) =&gt; { \n  cy.get('input').type('Bye')\n})\n</code></pre>\n<h2>Keep it DRY</h2>\n<p>There are certain checks that you may want to do multiple times, or actions you want to perform before each test. Cypress gives you the ability to write your own custom commands to be used throughout the testing suite. One that we use extensively is cy.auth(), this is a command that mocks out the authentication request as all of our routes are protected. You can also add other commands for any tasks you do repeatedly.</p>\n<pre><code class=\"language-javascript\">Cypress.Commands.add('auth', () =&gt; {\n  cy.server()\n  cy.fixture('auth').as('auth')\n  cy.route('GET', '/v1/auth', '@auth')\n})\n\n// This can be called within our tests like this:\ncy.auth()\n</code></pre>\n<h2>Common issues faced</h2>\n<p>When building out or E2E tests there were a number of issues that we had to overcome to ensure that they work reliably. Our major pain point was in our CI environment (Circle CI) the tests would fail very often.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*rzBqx4sW2xu4l8uWNJneBw.jpeg\" alt=\"\"></p>\n<p>There can be a number of things that could be going wrong that can ultimately cause tests to fail but the first step is identifying where there are issues.</p>\n<h2>Page performance issues</h2>\n<p>We found that some of the pages were just not performant enough which would cause Cypress to timeout as it wasn’t able to find the DOM nodes in time as the javascript hadn’t finished evaluating. One of the ways to check this is to run the tests multiple times and find the ones that fail, you can do this by running the following command:</p>\n<pre><code class=\"language-javascript\">// Run the tests x number of times\nCypress._.times(20, (i) =&gt; {\n  it(`something ${i} times`, () =&gt; {\n  \n  })\n})\n</code></pre>\n<p>To take this a step further, as the tests are running in a chrome browser it is possible to throttle CPU and network speed. You can do this by clicking in Dev Tools&gt;Performance</p>\n<p>If you find tests are failing then it means that something on the page isn’t rendering fast enough for Cypress to find it. You can get past this by adding an increased timeout in your before hook but ideally you would fix the underlying problem:</p>\n<pre><code class=\"language-javascript\">// Not ideal to do this as there is an underlying issue with \n// the page performance to necessitate doing this.\nbefore(() =&gt; {\n  Cypress.config('defaultCommandTimeout', 20000)\n})\n</code></pre>\n<h2>Fixtures were too large</h2>\n<p>Initially, when we were writing our tests we were testing using real data from our staging environment, the issue with this is that if there are any issues with the API then the test will fail. A good rule of thumb is to test the critical routes ( e.g. authentication, purchases and anything critical for the business) with a real API and to stub out the rest of the API request/responses.</p>\n<p>As we refactored our tests to use fixture data, one of the issues we faced when writing the tests was that the stubbing of the requests was failing if the JSON representation of the data was too large. Unfortunately, Cypress doesn’t warn you of this so it was only when digging through the Github issues we were able to discover this particular issue. We then had to manually go through the data and trim it down so that Cypress could be able to stub out the API calls correctly.</p>\n<h2>Best practices and key learnings</h2>\n<ul>\n<li>\n<p>Mock out as much of the data as possible, ideally using factories to generate random data on the fly — we use <a href=\"https://chancejs.com/\">chance.js</a> for this purpose.</p>\n</li>\n<li>\n<p>Mock everything except the critical routes.</p>\n</li>\n<li>\n<p>If tests are failing it is more than likely an issue with your App rather than Cypress.</p>\n</li>\n<li>\n<p>Performance test the pages where the tests are failing.</p>\n</li>\n<li>\n<p>Use the <a href=\"https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground\">selector playground</a> for finding DOM elements, makes writing tests much quicker.</p>\n</li>\n<li>\n<p>Don’t use the data property for finding elements, this can break once the JS/CSS is recompiled and these values change.</p>\n</li>\n<li>\n<p>Use cy.wait() to wait for API calls to finish.</p>\n</li>\n<li>\n<p>When writing frontend code where the state of the application needs to change via UI interaction, Cypress is a great way of automating it.</p>\n</li>\n</ul>\n",attributes:{name:"automating-user-interactions-with-cypress",title:"Automating user interactions with Cypress",year:"19 Aug 2019",id:"automating-user-interactions-with-cypress",description:"My experience using Cypress to automate user interactions for testing and development\n",_meta:{resourcePath:"/Users/clementvenard/github.com/clem109/clem109/contents/en/blog/automating-user-interactions-with-cypress.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'p\',[_vm._v("At Thriva we are hard at work building the world’s first preventative healthcare company to change the way in which people think about their health. We deeply care about ensuring all our customers have a seamless experience when using our service and one of the ways we do this is by writing end-to-end (E2E) tests using Cypress. Cypress allows you to automate the way in which users interact with the application in the browser, this can be extremely useful for catching bugs but also during the development process.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://cdn-images-1.medium.com/max/2000/1*k4-5E9kKm4oqb6wn4FmaSg.jpeg","alt":""}})]),_vm._v(" "),_c(\'h2\',[_vm._v("What is Cypress?")]),_vm._v(" "),_c(\'p\',[_vm._v("Cypress is a javascript framework for writing E2E tests for web applications, it has mocking, stubbing and assertions built in. As it was built from the ground up, it doesn’t use Selenium at all and is (usually) very performant.")]),_vm._v(" "),_c(\'p\',[_vm._v("Writing the E2E tests is usually trivial, however we came across a few issues which I will detail in this article that should be useful for anyone else using Cypress.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Setup")]),_vm._v(" "),_c(\'p\',[_vm._v("The majority of the Thriva website is built using "),_c(\'a\',{attrs:{"href":"https://vuejs.org/"}},[_vm._v("Vue.js")]),_vm._v(", as we scaffolded the project with the Vue cli we get Cypress installed out of the box. It is relatively easy to install by "),_c(\'a\',{attrs:{"href":"https://docs.cypress.io/guides/getting-started/installing-cypress.html"}},[_vm._v("following the instructions in the docs")])]),_vm._v(" "),_c(\'p\',[_vm._v("Below is the folder structure for Cypress:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("# Cypress file structure\\n/fixtures\\n/plugins\\n/specs\\n/support\\n")])]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_c(\'p\',[_vm._v("Fixtures — where you store the files that will be used to mock API calls, images, videos etc.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Plugins — provide a way of modifying the internal behaviour of Cypress")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Specs — this is where you write your E2E tests")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Support — a place to write utility functions, for example, a function that handles user authentication")])])]),_vm._v(" "),_c(\'h2\',[_vm._v("Writing E2E tests")]),_vm._v(" "),_c(\'p\',[_vm._v("The Cypress docs are fairly comprehensive when it comes to describing the best way of writing E2E tests. Here I will show some of the more useful features that I found when writing E2E tests.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Stubbing data")]),_vm._v(" "),_c(\'p\',[_vm._v("Cypress allows you to catch API requests and stub out their data, below we are listening to GET requests to the /v1/auth API endpoint and we return the user fixture. Cypress is clever and is able to find the user.json file within the fixtures folder, we can also add stubs for images, videos etc.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("cy.server()\\ncy.fixture(\'user\').as(\'user\')\\ncy.route(\'GET\', \'/v1/auth\', \'@user\')\\n\\n// user.json\\n{\\n  firstName: \'Clem\',\\n  lastName: \'JavaScript\',\\n  company: \'Thriva Health\',\\n  bloodResults: [\\n    {\\n      type: \'HbA1c\',\\n      result: 30.4,\\n      units: \'mmol/mol\',\\n      severity: \'normal\'\\n    }\\n  ]\\n}\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Editing mocks on the fly")]),_vm._v(" "),_c(\'p\',[_vm._v("Sometimes you want to test the application under different states, for example, let’s say that we want to test the graph which displays our blood results for a different result value and a high severity. We can edit the fixture before it is used in the test:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("cy.server()\\ncy.fixture(\'user\').then((user) => {\\n  user.bloodResults = [\\n    {\\n      type: \'HbA1c\',\\n      result: 60.3,\\n      units: \'mmol/mol\',\\n      severity: \'high\'\\n    }\\n  ]\\n  cy.route(\'GET\', \'v1/auth/**\', user).as(\'user\')\\n})\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Waiting for API requests")]),_vm._v(" "),_c(\'p\',[_vm._v("In certain situations you want to call a real API, perhaps to test your authentication flow. In this case you would want to wait for the API to resolve before continuing with the test. At Thriva we have a page where you can personalise your blood tests to your own personal needs, we need to call our API to get all the pricing’s for all of the different types of tests we offer. We can use cy.wait() to wait for the API to finish before performing our E2E tests:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("cy.server()\\ncy.route({\\n  method: \'GET\',\\n  url: `/v1/blood_tests`\\n}).as(\'bloodTests\')\\ncy.wait(\'@blootTests\')\\n\\n// once this has resolved then the rest of the tests can be run\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Writing tests for different devices")]),_vm._v(" "),_c(\'p\',[_vm._v("By default Cypress runs in a desktop web browser, in reality there is a high probability that the vast majority of your users are accessing the website with their mobile device. Cypress allows you to run your tests as though you were interacting with the app on a mobile, tablet and/or desktop:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("// Good\\nbeforeAll(() => {\\n  cy.viewport(\'iphone-6\')\\n})\\n\\n// Bad - each time you write an it assertion the browser will reset to a desktop browser.\\nbefore(() => {\\n  cy.viewport(\'iphone-6\')\\n})\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("The viewport function can take different parameters to render the page at different screen resolutions.")]),_vm._v(" "),_c(\'h2\',[_vm._v("E2E tests are not unit tests")]),_vm._v(" "),_c(\'p\',[_vm._v("When writing E2E tests it is not necessary to write assertions for everything like you would in a unit test. Rather, it is better to write assertions for overall functionality — Cypress was designed to be written this way:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("describe(\'To do app\', () => {\\n  context(\'Desktop\', () => {\\n    before(() => {\\n      //mock out auth\\n      cy.server()\\n      cy.fixture(\'user\').as(\'user\')\\n      cy.route(\'GET\', \'/v1/auth\', \'@user\')\\n      // mock out todos\\n      cy.fixture(\'todos\').as(\'todos\')\\n      cy.route(\'GET\', \'/v1/todos\', \'@todos\')\\n    })\\n    \\n    // GOOD\\n    it(\'should be able to add and remove items to the todos\', () =>      {\\n    // logic to add and remove tests, asserting class names present \\n    // and correct to do length\\n      Cypress._.times(3, (i) => {\\n        cy.get(\'.todo-input\').type(`test: ${i}`)\\n        cy.contains(\'Add todo\').click()\\n      })\\n      cy.get(\'.todo\').should(\'have.length\', 3)\\n\\n      Cypress._.times(3, (i) => {\\n        cy.get(\'.remove-todo\').first().click()\\n      })\\n      cy.get(\'.todo\').should(\'have.length\', 0)\\n}\\n\\n    // BAD\\n    it(\'should have the .added class when todo is added\')\\n\\n    // BAD\\n    it(\'should have X number of items added to the todo list\')\\n  })\\n})\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Selector Playground")]),_vm._v(" "),_c(\'p\',[_vm._v("The selector playground is probably my favourite feature about Cypress, rather than having to write out all your CSS selectors to find the DOM elements manually this tools finds them for you. "),_c(\'a\',{attrs:{"href":"https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground"}},[_vm._v("The documentation")]),_vm._v(" explains very well how to use this correctly.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Look within")]),_vm._v(" "),_c(\'p\',[_vm._v("There are times when it is difficult to write query selectors as there are multiple places where there could be a match, this is particularly problematic on forms if you are trying to find a particular input element. Cypress allows you to find the parent DOM element and only look at the child elements within it:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-html"}},[_vm._v("<form class=\'some-form\'>\\n  <div id=\'one\'>\\n    <input />\\n  </div>\\n  \\n  <div id=\'two\'>\\n    <input />\\n  </div>\\n  \\n  <div id=\'three\'>\\n    <input />\\n  </div>\\n</form>\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Lets say you want to go through the form and fill out each individual input:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("cy.within(\'#one\', ($el) => { \\n  cy.get(\'input\').type(\'Hello\')\\n})\\n\\ncy.within(\'#two\', ($el) => { \\n  cy.get(\'input\').type(\'Maybe\')\\n})\\n\\ncy.within(\'#three\', ($el) => { \\n  cy.get(\'input\').type(\'Bye\')\\n})\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Keep it DRY")]),_vm._v(" "),_c(\'p\',[_vm._v("There are certain checks that you may want to do multiple times, or actions you want to perform before each test. Cypress gives you the ability to write your own custom commands to be used throughout the testing suite. One that we use extensively is cy.auth(), this is a command that mocks out the authentication request as all of our routes are protected. You can also add other commands for any tasks you do repeatedly.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("Cypress.Commands.add(\'auth\', () => {\\n  cy.server()\\n  cy.fixture(\'auth\').as(\'auth\')\\n  cy.route(\'GET\', \'/v1/auth\', \'@auth\')\\n})\\n\\n// This can be called within our tests like this:\\ncy.auth()\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Common issues faced")]),_vm._v(" "),_c(\'p\',[_vm._v("When building out or E2E tests there were a number of issues that we had to overcome to ensure that they work reliably. Our major pain point was in our CI environment (Circle CI) the tests would fail very often.")]),_vm._v(" "),_c(\'p\',[_c(\'img\',{attrs:{"src":"https://cdn-images-1.medium.com/max/2000/1*rzBqx4sW2xu4l8uWNJneBw.jpeg","alt":""}})]),_vm._v(" "),_c(\'p\',[_vm._v("There can be a number of things that could be going wrong that can ultimately cause tests to fail but the first step is identifying where there are issues.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Page performance issues")]),_vm._v(" "),_c(\'p\',[_vm._v("We found that some of the pages were just not performant enough which would cause Cypress to timeout as it wasn’t able to find the DOM nodes in time as the javascript hadn’t finished evaluating. One of the ways to check this is to run the tests multiple times and find the ones that fail, you can do this by running the following command:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("// Run the tests x number of times\\nCypress._.times(20, (i) => {\\n  it(`something ${i} times`, () => {\\n  \\n  })\\n})\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("To take this a step further, as the tests are running in a chrome browser it is possible to throttle CPU and network speed. You can do this by clicking in Dev Tools>Performance")]),_vm._v(" "),_c(\'p\',[_vm._v("If you find tests are failing then it means that something on the page isn’t rendering fast enough for Cypress to find it. You can get past this by adding an increased timeout in your before hook but ideally you would fix the underlying problem:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("// Not ideal to do this as there is an underlying issue with \\n// the page performance to necessitate doing this.\\nbefore(() => {\\n  Cypress.config(\'defaultCommandTimeout\', 20000)\\n})\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Fixtures were too large")]),_vm._v(" "),_c(\'p\',[_vm._v("Initially, when we were writing our tests we were testing using real data from our staging environment, the issue with this is that if there are any issues with the API then the test will fail. A good rule of thumb is to test the critical routes ( e.g. authentication, purchases and anything critical for the business) with a real API and to stub out the rest of the API request/responses.")]),_vm._v(" "),_c(\'p\',[_vm._v("As we refactored our tests to use fixture data, one of the issues we faced when writing the tests was that the stubbing of the requests was failing if the JSON representation of the data was too large. Unfortunately, Cypress doesn’t warn you of this so it was only when digging through the Github issues we were able to discover this particular issue. We then had to manually go through the data and trim it down so that Cypress could be able to stub out the API calls correctly.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Best practices and key learnings")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_c(\'p\',[_vm._v("Mock out as much of the data as possible, ideally using factories to generate random data on the fly — we use "),_c(\'a\',{attrs:{"href":"https://chancejs.com/"}},[_vm._v("chance.js")]),_vm._v(" for this purpose.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Mock everything except the critical routes.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("If tests are failing it is more than likely an issue with your App rather than Cypress.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Performance test the pages where the tests are failing.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Use the "),_c(\'a\',{attrs:{"href":"https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground"}},[_vm._v("selector playground")]),_vm._v(" for finding DOM elements, makes writing tests much quicker.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Don’t use the data property for finding elements, this can break once the JS/CSS is recompiled and these values change.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("Use cy.wait() to wait for API calls to finish.")])]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_vm._v("When writing frontend code where the state of the application needs to change via UI interaction, Cypress is a great way of automating it.")])])])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"dynamicMarkdown"},[n("p",[e._v("At Thriva we are hard at work building the world’s first preventative healthcare company to change the way in which people think about their health. We deeply care about ensuring all our customers have a seamless experience when using our service and one of the ways we do this is by writing end-to-end (E2E) tests using Cypress. Cypress allows you to automate the way in which users interact with the application in the browser, this can be extremely useful for catching bugs but also during the development process.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://cdn-images-1.medium.com/max/2000/1*k4-5E9kKm4oqb6wn4FmaSg.jpeg",alt:""}})]),e._v(" "),n("h2",[e._v("What is Cypress?")]),e._v(" "),n("p",[e._v("Cypress is a javascript framework for writing E2E tests for web applications, it has mocking, stubbing and assertions built in. As it was built from the ground up, it doesn’t use Selenium at all and is (usually) very performant.")]),e._v(" "),n("p",[e._v("Writing the E2E tests is usually trivial, however we came across a few issues which I will detail in this article that should be useful for anyone else using Cypress.")]),e._v(" "),n("h2",[e._v("Setup")]),e._v(" "),n("p",[e._v("The majority of the Thriva website is built using "),n("a",{attrs:{href:"https://vuejs.org/"}},[e._v("Vue.js")]),e._v(", as we scaffolded the project with the Vue cli we get Cypress installed out of the box. It is relatively easy to install by "),n("a",{attrs:{href:"https://docs.cypress.io/guides/getting-started/installing-cypress.html"}},[e._v("following the instructions in the docs")])]),e._v(" "),n("p",[e._v("Below is the folder structure for Cypress:")]),e._v(" "),n("pre",[n("code",{pre:!0},[e._v("# Cypress file structure\n/fixtures\n/plugins\n/specs\n/support\n")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Fixtures — where you store the files that will be used to mock API calls, images, videos etc.")])]),e._v(" "),n("li",[n("p",[e._v("Plugins — provide a way of modifying the internal behaviour of Cypress")])]),e._v(" "),n("li",[n("p",[e._v("Specs — this is where you write your E2E tests")])]),e._v(" "),n("li",[n("p",[e._v("Support — a place to write utility functions, for example, a function that handles user authentication")])])]),e._v(" "),n("h2",[e._v("Writing E2E tests")]),e._v(" "),n("p",[e._v("The Cypress docs are fairly comprehensive when it comes to describing the best way of writing E2E tests. Here I will show some of the more useful features that I found when writing E2E tests.")]),e._v(" "),n("h2",[e._v("Stubbing data")]),e._v(" "),n("p",[e._v("Cypress allows you to catch API requests and stub out their data, below we are listening to GET requests to the /v1/auth API endpoint and we return the user fixture. Cypress is clever and is able to find the user.json file within the fixtures folder, we can also add stubs for images, videos etc.")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("cy.server()\ncy.fixture('user').as('user')\ncy.route('GET', '/v1/auth', '@user')\n\n// user.json\n{\n  firstName: 'Clem',\n  lastName: 'JavaScript',\n  company: 'Thriva Health',\n  bloodResults: [\n    {\n      type: 'HbA1c',\n      result: 30.4,\n      units: 'mmol/mol',\n      severity: 'normal'\n    }\n  ]\n}\n")])]),e._v(" "),n("h2",[e._v("Editing mocks on the fly")]),e._v(" "),n("p",[e._v("Sometimes you want to test the application under different states, for example, let’s say that we want to test the graph which displays our blood results for a different result value and a high severity. We can edit the fixture before it is used in the test:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("cy.server()\ncy.fixture('user').then((user) => {\n  user.bloodResults = [\n    {\n      type: 'HbA1c',\n      result: 60.3,\n      units: 'mmol/mol',\n      severity: 'high'\n    }\n  ]\n  cy.route('GET', 'v1/auth/**', user).as('user')\n})\n")])]),e._v(" "),n("h2",[e._v("Waiting for API requests")]),e._v(" "),n("p",[e._v("In certain situations you want to call a real API, perhaps to test your authentication flow. In this case you would want to wait for the API to resolve before continuing with the test. At Thriva we have a page where you can personalise your blood tests to your own personal needs, we need to call our API to get all the pricing’s for all of the different types of tests we offer. We can use cy.wait() to wait for the API to finish before performing our E2E tests:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("cy.server()\ncy.route({\n  method: 'GET',\n  url: `/v1/blood_tests`\n}).as('bloodTests')\ncy.wait('@blootTests')\n\n// once this has resolved then the rest of the tests can be run\n")])]),e._v(" "),n("h2",[e._v("Writing tests for different devices")]),e._v(" "),n("p",[e._v("By default Cypress runs in a desktop web browser, in reality there is a high probability that the vast majority of your users are accessing the website with their mobile device. Cypress allows you to run your tests as though you were interacting with the app on a mobile, tablet and/or desktop:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("// Good\nbeforeAll(() => {\n  cy.viewport('iphone-6')\n})\n\n// Bad - each time you write an it assertion the browser will reset to a desktop browser.\nbefore(() => {\n  cy.viewport('iphone-6')\n})\n")])]),e._v(" "),n("p",[e._v("The viewport function can take different parameters to render the page at different screen resolutions.")]),e._v(" "),n("h2",[e._v("E2E tests are not unit tests")]),e._v(" "),n("p",[e._v("When writing E2E tests it is not necessary to write assertions for everything like you would in a unit test. Rather, it is better to write assertions for overall functionality — Cypress was designed to be written this way:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("describe('To do app', () => {\n  context('Desktop', () => {\n    before(() => {\n      //mock out auth\n      cy.server()\n      cy.fixture('user').as('user')\n      cy.route('GET', '/v1/auth', '@user')\n      // mock out todos\n      cy.fixture('todos').as('todos')\n      cy.route('GET', '/v1/todos', '@todos')\n    })\n    \n    // GOOD\n    it('should be able to add and remove items to the todos', () =>      {\n    // logic to add and remove tests, asserting class names present \n    // and correct to do length\n      Cypress._.times(3, (i) => {\n        cy.get('.todo-input').type(`test: ${i}`)\n        cy.contains('Add todo').click()\n      })\n      cy.get('.todo').should('have.length', 3)\n\n      Cypress._.times(3, (i) => {\n        cy.get('.remove-todo').first().click()\n      })\n      cy.get('.todo').should('have.length', 0)\n}\n\n    // BAD\n    it('should have the .added class when todo is added')\n\n    // BAD\n    it('should have X number of items added to the todo list')\n  })\n})\n")])]),e._v(" "),n("h2",[e._v("Selector Playground")]),e._v(" "),n("p",[e._v("The selector playground is probably my favourite feature about Cypress, rather than having to write out all your CSS selectors to find the DOM elements manually this tools finds them for you. "),n("a",{attrs:{href:"https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground"}},[e._v("The documentation")]),e._v(" explains very well how to use this correctly.")]),e._v(" "),n("h2",[e._v("Look within")]),e._v(" "),n("p",[e._v("There are times when it is difficult to write query selectors as there are multiple places where there could be a match, this is particularly problematic on forms if you are trying to find a particular input element. Cypress allows you to find the parent DOM element and only look at the child elements within it:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-html"}},[e._v("<form class='some-form'>\n  <div id='one'>\n    <input />\n  </div>\n  \n  <div id='two'>\n    <input />\n  </div>\n  \n  <div id='three'>\n    <input />\n  </div>\n</form>\n")])]),e._v(" "),n("p",[e._v("Lets say you want to go through the form and fill out each individual input:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("cy.within('#one', ($el) => { \n  cy.get('input').type('Hello')\n})\n\ncy.within('#two', ($el) => { \n  cy.get('input').type('Maybe')\n})\n\ncy.within('#three', ($el) => { \n  cy.get('input').type('Bye')\n})\n")])]),e._v(" "),n("h2",[e._v("Keep it DRY")]),e._v(" "),n("p",[e._v("There are certain checks that you may want to do multiple times, or actions you want to perform before each test. Cypress gives you the ability to write your own custom commands to be used throughout the testing suite. One that we use extensively is cy.auth(), this is a command that mocks out the authentication request as all of our routes are protected. You can also add other commands for any tasks you do repeatedly.")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("Cypress.Commands.add('auth', () => {\n  cy.server()\n  cy.fixture('auth').as('auth')\n  cy.route('GET', '/v1/auth', '@auth')\n})\n\n// This can be called within our tests like this:\ncy.auth()\n")])]),e._v(" "),n("h2",[e._v("Common issues faced")]),e._v(" "),n("p",[e._v("When building out or E2E tests there were a number of issues that we had to overcome to ensure that they work reliably. Our major pain point was in our CI environment (Circle CI) the tests would fail very often.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://cdn-images-1.medium.com/max/2000/1*rzBqx4sW2xu4l8uWNJneBw.jpeg",alt:""}})]),e._v(" "),n("p",[e._v("There can be a number of things that could be going wrong that can ultimately cause tests to fail but the first step is identifying where there are issues.")]),e._v(" "),n("h2",[e._v("Page performance issues")]),e._v(" "),n("p",[e._v("We found that some of the pages were just not performant enough which would cause Cypress to timeout as it wasn’t able to find the DOM nodes in time as the javascript hadn’t finished evaluating. One of the ways to check this is to run the tests multiple times and find the ones that fail, you can do this by running the following command:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("// Run the tests x number of times\nCypress._.times(20, (i) => {\n  it(`something ${i} times`, () => {\n  \n  })\n})\n")])]),e._v(" "),n("p",[e._v("To take this a step further, as the tests are running in a chrome browser it is possible to throttle CPU and network speed. You can do this by clicking in Dev Tools>Performance")]),e._v(" "),n("p",[e._v("If you find tests are failing then it means that something on the page isn’t rendering fast enough for Cypress to find it. You can get past this by adding an increased timeout in your before hook but ideally you would fix the underlying problem:")]),e._v(" "),n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("// Not ideal to do this as there is an underlying issue with \n// the page performance to necessitate doing this.\nbefore(() => {\n  Cypress.config('defaultCommandTimeout', 20000)\n})\n")])]),e._v(" "),n("h2",[e._v("Fixtures were too large")]),e._v(" "),n("p",[e._v("Initially, when we were writing our tests we were testing using real data from our staging environment, the issue with this is that if there are any issues with the API then the test will fail. A good rule of thumb is to test the critical routes ( e.g. authentication, purchases and anything critical for the business) with a real API and to stub out the rest of the API request/responses.")]),e._v(" "),n("p",[e._v("As we refactored our tests to use fixture data, one of the issues we faced when writing the tests was that the stubbing of the requests was failing if the JSON representation of the data was too large. Unfortunately, Cypress doesn’t warn you of this so it was only when digging through the Github issues we were able to discover this particular issue. We then had to manually go through the data and trim it down so that Cypress could be able to stub out the API calls correctly.")]),e._v(" "),n("h2",[e._v("Best practices and key learnings")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Mock out as much of the data as possible, ideally using factories to generate random data on the fly — we use "),n("a",{attrs:{href:"https://chancejs.com/"}},[e._v("chance.js")]),e._v(" for this purpose.")])]),e._v(" "),n("li",[n("p",[e._v("Mock everything except the critical routes.")])]),e._v(" "),n("li",[n("p",[e._v("If tests are failing it is more than likely an issue with your App rather than Cypress.")])]),e._v(" "),n("li",[n("p",[e._v("Performance test the pages where the tests are failing.")])]),e._v(" "),n("li",[n("p",[e._v("Use the "),n("a",{attrs:{href:"https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground"}},[e._v("selector playground")]),e._v(" for finding DOM elements, makes writing tests much quicker.")])]),e._v(" "),n("li",[n("p",[e._v("Don’t use the data property for finding elements, this can break once the JS/CSS is recompiled and these values change.")])]),e._v(" "),n("li",[n("p",[e._v("Use cy.wait() to wait for API calls to finish.")])]),e._v(" "),n("li",[n("p",[e._v("When writing frontend code where the state of the application needs to change via UI interaction, Cypress is a great way of automating it.")])])])])}]}}}}}}]);